Flow:
React App (served via CloudFront) → API Gateway → Lambda (in a VPC) → NAT Gateway (with Elastic IP) → External Endpoint

Key Points:

The Lambda function will run inside a private subnet of your VPC.
The private subnet will route outbound traffic through a NAT Gateway, which has a fixed Elastic IP.
You will whitelist the NAT Gateway’s Elastic IP at the external endpoint.
API Gateway will be the publicly accessible endpoint your CloudFront-distributed React app can call.
The Lambda function will receive the file from the React app (via API Gateway), then forward it to the external endpoint using the required headers and basic authentication.
Step-by-Step Setup
Prerequisites
A React application already deployed behind CloudFront (this provides an HTTPS endpoint that can reach your API Gateway).
Access to AWS to configure VPC, NAT Gateway, API Gateway, Lambda, and IAM roles.
Credentials for the external endpoint (username/password) and the endpoint URL.
1. Set Up the VPC and NAT Gateway for a Stable IP
Create a VPC:

In the AWS Console, go to VPC → Your VPCs → Create VPC.
Choose a CIDR block (e.g., 10.0.0.0/16) and create the VPC.
Create Subnets:

Create one public subnet (e.g., 10.0.1.0/24) for the NAT Gateway.
Create one private subnet (e.g., 10.0.2.0/24) for the Lambda function.
Create and Attach an Internet Gateway:

Still in VPC console, create an Internet Gateway.
Attach it to your VPC.
Route Table for Public Subnet:

For the public subnet, associate a route table that has a route to the Internet Gateway (e.g., 0.0.0.0/0 → InternetGatewayID).
Create an Elastic IP and NAT Gateway:

Allocate a new Elastic IP in the VPC console.
Create a NAT Gateway in the public subnet using this Elastic IP.
This Elastic IP is your stable outbound IP address. Whitelist this IP in your external system.
Route Table for Private Subnet:

For the private subnet, use a route table that sends all outbound traffic to the NAT Gateway (e.g., 0.0.0.0/0 → NATGatewayID).
Associate this route table with the private subnet.
At this point, any resources (like Lambda) placed in the private subnet will have outbound internet access via the NAT Gateway, presenting the stable Elastic IP to external endpoints.

2. Create the Lambda Function in the Private Subnet
Create an IAM Role for Lambda:

Go to IAM → Roles → Create role.
Choose "Lambda" as the trusted entity.
Attach policies like AWSLambdaBasicExecutionRole.
Save the role.
Create the Lambda Function:

In the Lambda console, create a new function.
Runtime: Node.js or Python (example will assume Node.js).
Under "Advanced settings" or "Configuration", choose the VPC, the private subnet you created, and the appropriate security group. The security group should allow outbound HTTPS (port 443).
This ensures the Lambda runs in your private subnet and egresses through the NAT Gateway.
Write the Lambda Code: The Lambda should:

Parse the incoming file binary from API Gateway.
Forward it via axios or https module to the external endpoint.
Example Node.js pseudocode:

js
Copy code
const https = require('https');
const { Buffer } = require('buffer');

exports.handler = async (event) => {
  try {
    // event.body should contain the file binary (base64 encoded if via API Gateway)
    const body = Buffer.from(event.body, 'base64');

    const options = {
      method: 'POST',
      hostname: 'stockmann-tst.mdm.stibosystems.com',
      path: '/restapiv2/inbound-integration-endpoints/iiep_buyside_rest/upload-and-invoke?context=International&workspace=Main',
      headers: {
        'Content-Type': 'application/octet-stream',
        'accept': '*/*',
        // Basic Auth:
        'Authorization': 'Basic ' + Buffer.from('kandrak:Welcome@123').toString('base64'),
        'Content-Length': body.length
      }
    };

    return await new Promise((resolve, reject) => {
      const req = https.request(options, (res) => {
        let responseData = '';
        res.on('data', chunk => responseData += chunk);
        res.on('end', () => {
          resolve({
            statusCode: res.statusCode,
            body: responseData
          });
        });
      });

      req.on('error', (err) => reject(err));
      req.write(body);
      req.end();
    });

  } catch (error) {
    return {
      statusCode: 500,
      body: JSON.stringify({ error: error.message })
    };
  }
};
Note:

Make sure your API Gateway integration is set to use binary media types and you pass the file as binary from the React front end.
Ensure the function’s execution role has sufficient permissions (basic execution role is usually enough since we only do outbound calls).
3. Set Up API Gateway to Invoke the Lambda
Create an API in API Gateway:

In the API Gateway console, create a new REST API or HTTP API.
For simplicity, choose HTTP API for lower latency and easier setup.
Integrate with Lambda:

Configure a route (e.g., POST /upload).
Set the integration target to your Lambda function.
Make sure to allow binary media if you're passing a binary file (this may be more straightforward with REST APIs rather than HTTP APIs, as HTTP APIs have limited binary support. If complexity arises, use a REST API and specify multipart/form-data or application/octet-stream as binary).
Deployment and Endpoint:

Deploy the API and note the endpoint URL.
4. Configure CloudFront and Your React App to Use the Proxy
Your React app is hosted on CloudFront and presumably makes a POST request to the proxy endpoint. For example:

React front-end POSTs file to https://<your-api-gateway-id>.execute-api.<region>.amazonaws.com/upload.
Ensure the request is sent as binary or as a form that your Lambda can parse. Often, you’ll upload as application/octet-stream and base64 encode if necessary. For a binary payload through API Gateway REST API, you need to:

In API Gateway (if using REST API), go to binary media settings under the API’s settings and add application/octet-stream.
Your Lambda code expects event.body to be base64 encoded binary. Also, set isBase64Encoded: true in your API’s response if necessary.
5. Test and Whitelist the IP
Test the Flow:

From your React app, initiate a file upload.
CloudFront → API Gateway → Lambda → external endpoint.
Check logs in CloudWatch for Lambda.
Check if the external endpoint received the file.
Whitelist the IP:

The stable IP is the Elastic IP of your NAT Gateway.
Provide this IP to your external endpoint’s administrators.
They whitelist it on their VPN/firewall.
Once whitelisted, all traffic from your Lambda to the external endpoint will appear from this stable Elastic IP.




Mid-Level Summary of What Was Done:

React App & CloudFront:
You started with a React frontend application served via AWS CloudFront. This front end needed to send files to an external endpoint over the internet.

API Gateway Setup:
To securely expose your Lambda function and control access, you created an API Gateway REST API. This API acts as the public endpoint that your React app can call.

Lambda Function:
You wrote a Lambda function to act as a proxy. The Lambda receives the file from API Gateway and then makes an outbound HTTPS request to the external endpoint. Initially, the Lambda code expected a binary-encoded file and returned CORS headers so the browser would allow cross-origin requests.

VPC and NAT Gateway:
To have a stable outbound IP address that you can whitelist at the external service, you placed the Lambda in a private subnet within a VPC. Outbound traffic from this subnet goes through a NAT Gateway. This NAT Gateway has an Elastic IP, providing a fixed public IP address for outbound requests.

Binary Media Types & Content Type Adjustments:
You had to configure API Gateway to handle binary data (application/octet-stream) so that the file would be base64-encoded and properly passed to the Lambda. On the front end, you stopped using FormData (which triggers multipart/form-data) and sent the file directly as application/octet-stream. This allowed API Gateway to treat it as binary data and the Lambda to receive it in the correct format.

CORS Configuration:
You enabled CORS in API Gateway and returned appropriate CORS headers from the Lambda. This ensured that the React app hosted on a different domain (CloudFront) could call the API Gateway endpoint without being blocked by the browser.

Whitelisting the NAT Gateway’s IP:
With all the above configuration done, the only remaining step for the external endpoint to accept your requests is to whitelist the NAT Gateway’s Elastic IP. This ensures the external service sees a known, allowed IP address for inbound requests from your Lambda function.

In short:
You built a chain from your React front end to a private Lambda function inside a VPC. The Lambda calls the external system via a NAT Gateway’s stable IP. You adjusted API Gateway and your front end to send data as binary so the Lambda could correctly forward the file. Finally, you identified the NAT Gateway’s Elastic IP to whitelist on the external system’s firewall.